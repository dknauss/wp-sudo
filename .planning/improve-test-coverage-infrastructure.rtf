# Improve Test Coverage Infrastructure

## Context

WP Sudo has 489 tests (397 unit + 92 integration) with all 10 production classes covered, but no actual code coverage measurement exists. The `phpunit.xml.dist` files declare `<coverage><include>[...]`

Beyond measurement, three specific gaps carry real risk:

1. **Challenge class** — has unit tests only; the most security-critical flow (password verification → session grant → stash replay) has no integration test
2. **`uninstall.php`** — has zero tests; cleans up roles, options, and user meta across multisite networks
3. **Coverage reporting** — no baseline, no regression prevention

## Plan

### Step 1: Add PCOV coverage to CI (one matrix entry only)

**Files:** `.github/workflows/phpunit.yml`, `composer.json`

In the unit-tests job, add a dedicated coverage step for PHP 8.3 only (coverage is deterministic across PHP versions — running it on all 4 would waste CI minutes):

- Add a new job `unit-tests-coverage` that runs after unit-tests, PHP 8.3 only
- Use `shivammathur/setup-php` with `coverage: pcov` (not xdebug — PCOV is ~10x faster)
- Run: `./vendor/bin/phpunit --configuration phpunit.xml.dist --coverage-clover coverage.xml --coverage-text`
- Upload `coverage.xml` as an artifact for inspection
- **Do not** set a failure threshold yet — first run establishes the baseline

Add a composer script for local use:

```json
"test:coverage": "phpunit --configuration phpunit.xml.dist --coverage-clover coverage.xml --coverage-text"
```

**Note:** PCOV is a PHP extension installed by `shivammathur/setup-php`, not a Composer dependency. No change to `composer.json` dependencies. Only the scripts section gets the convenience alias.

### Step 2: Add Challenge integration test

**File:** `tests/Integration/ChallengeTest.php`

Write TDD-style (failing test first). This test exercises the security-critical path that currently has unit tests only:

1. **Setup:** Create admin user with known password via `make_admin()`
2. **Gated request:** Simulate plugin activation → `Gate::match_request()` returns rule
3. **Stash:** `Request_Stash::save()` — verify transient created
4. **Wrong password:** `Sudo_Session::attempt_activation($user_id, 'wrong')` — verify returns `'invalid_password'`, session NOT active, `wp_sudo_reauth_failed` hook fires
5. **Correct password:** `Sudo_Session::attempt_activation($user_id, $password)` — verify returns `'success'`, session IS active, `wp_sudo_activated` hook fires
6. **Token binding:** Verify `$_COOKIE[TOKEN_COOKIE]` exists, `hash('sha256', cookie) === stored meta`
7. **Stash replay:** `Request_Stash::get($key, $user_id)` — verify returns original request data, then `delete()` — verify gone

This mirrors the `ReauthFlowTest` pattern but focuses on Challenge-adjacent verification (wrong password path, hook firing, token chain) rather than the 5-class contract.

### Step 3: Add uninstall integration test

**File:** `tests/Integration/UninstallTest.php`

Two test methods:

#### `test_single_site_uninstall_cleans_all_data()`

1. Activate plugin (fires activation hook → removes `unfiltered_html` from editors)
2. Create admin user, activate sudo session (creates `_wp_sudo_*` user meta)
3. Verify meta and options exist
4. Require `uninstall.php` with `WP_UNINSTALL_PLUGIN` defined
5. Assert:
   - `wp_sudo_settings` option deleted
   - `_wp_sudo_expires` meta deleted
   - `_wp_sudo_token` meta deleted
   - `_wp_sudo_failed_attempts` meta deleted
   - `_wp_sudo_lockout_until` meta deleted
   - site roles restored

#### `test_multisite_uninstall_preserves_active_site_data()` (only runs when `WP_MULTISITE`)

1. Create 2 subsites via factory
2. On site A: activate plugin, create sudo session
3. On site B: do NOT activate (plugin not in `active_plugins`)
4. Run uninstall from site B context
5. Assert:
   - site B options cleaned
   - site A options preserved
   - user meta preserved (because site A still active)

**Note:** The uninstall file uses `is_multisite()`, `get_sites()`, `switch_to_blog()` — all real in the integration environment. The multisite test runs only in the `WP_MULTISITE=1` CI matrix.

### Step 4: Update `CLAUDE.md` and `ROADMAP.md`

Add the coverage command to the verification commands section:

```bash
# Code coverage (requires PCOV extension)
composer test:coverage   # Generates coverage.xml + terminal summary
```

Note in `ROADMAP.md` that coverage measurement is now available and the baseline should be recorded after the first CI run.

### Step 5: Commit and sync

- Commit: `test: add PCOV coverage CI job, Challenge and uninstall integration tests`
- Follow TDD: write failing tests first, then verify they pass against real code
- Push, sync to all 5 dev sites
- **No version bump** — test infrastructure changes don't warrant a release

## Files Modified

- `.github/workflows/phpunit.yml` — new `unit-tests-coverage` job
- `composer.json` — new `test:coverage` script alias
- `tests/Integration/ChallengeTest.php` — new file
- `tests/Integration/UninstallTest.php` — new file
- `CLAUDE.md` — coverage command in verification section
- `ROADMAP.md` — note coverage baseline

## Files Referenced (read-only)

- `phpunit.xml.dist` — already has `<coverage><include>` for `includes/`
- `phpunit-integration.xml.dist` — same
- `tests/Integration/TestCase.php` — base class with `make_admin()`, `simulate_admin_request()`, `activate_plugin()`
- `tests/Integration/ReauthFlowTest.php` — pattern to follow for Challenge test
- `uninstall.php` — the code under test for `UninstallTest`
- `includes/class-sudo-session.php` — `attempt_activation()`, `is_active()`, `TOKEN_COOKIE`, `TOKEN_META_KEY`
- `includes/class-request-stash.php` — `save()`, `get()`, `delete()`, `exists()`

## Verification

1. `composer test:unit` — existing 397 tests still pass
2. `composer test:integration` — existing 92 + new tests pass (locally, requires MySQL)
3. `composer test:coverage` — generates `coverage.xml`, terminal output shows line coverage % (requires PCOV locally; CI will run this)
4. `composer analyse -- --memory-limit=1G` — PHPStan clean
5. `composer lint` — PHPCS clean
